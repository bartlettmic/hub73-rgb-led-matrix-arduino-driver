#pragma once
#include "Definitions.h"
#include "Utility.h"

extern int16_t matrix[HEIGHT][WIDTH];
extern MPU6050 MPU;
extern uint16_t ticks;

namespace Fluid {

void draw() {
  MPU.read();
#define MPU_SENSITIVITY 400

  byte ax = constrain(MPU.raw[0] / MPU_SENSITIVITY, -2, 2);
  byte ay = constrain(MPU.raw[1] / MPU_SENSITIVITY, -2, 2);

  //  byte ax = MPU.precise[0]/MPU.precise[0]/MPU.precise[0];
  //  byte ay = MPU.precise[1]/MPU.precise[1]/MPU.precise[1];


  for (byte y = 0; y < HEIGHT; y++) {
    byte _c = (y << 2) + ticks;
    for (byte x = 0; x < WIDTH; x++) {
      if (!matrix[y][x]) continue;
      if (matrix[y][x] & 32768) continue;

      byte c = (x << 3)  + _c;
      matrix[y][x] = RGBsmash(rainbow(c - 170), rainbow(c - 85), rainbow(c)) | 32768;

      byte dx = x + ax;    if (dx < 0 || dx >= WIDTH) continue;
      byte dy = y + ay;    if (dy < 0 || dy >= HEIGHT) continue;

      if (matrix[dy][dx]) continue;

      matrix[dy][dx] = matrix[y][x]; // Flag moved pixel
      matrix[y][x] = 32768;

    }
  }

  // Clear all flags for next frame;
  for (byte y = 0; y < HEIGHT; y++) {
    for (byte x = 0; x < WIDTH; x++) {
      matrix[y][x] &= ~32768;
    }
  }

  delay(30);
  ticks+=4;
}

void setup() {
  memset(matrix, 0, sizeof(matrix));
  for (byte y = 0; y < HEIGHT; y++) {
    for (byte x = 0; x < WIDTH; x++) {
      randomSeed(analogRead(0) * analogRead(1) * analogRead(2));
      if (random(5) < 1) {
        //        byte c = random(256);
        byte c = 96;
        matrix[y][x] = RGBsmash(rainbow(c - 170), rainbow(c - 85), rainbow(c));
      }
      else {
        matrix[y][x] = 0;
      }
    }
  }
}
}


